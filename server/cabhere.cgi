#!/usr/local/bin/perl

# ------------------------------------------------------------------------------
#
# CabHere demo script
#
# This script handles the server side processing for the CabHere client running
# on an iPhone that is capable of providing 1) HTTP POST requests and
# 2) either latitude/longitude co-ordinates, or a street address.  The script
# logs the request for processing, which is making a referral available for a
# fake cab company to accept or reject the request.  The scripts handles
# requests for polled status updates, for cancelling the request, and for 
# reporting that the cab has arrived.
#
# Requests are by HTTP POST, with the following format (< > is required, 
# [ ] are strictly optional, though logically required for certain requests):
#
#     <action>:     <   request cab
#                     | request status
#                     | cancel cab
#                     | cab arrived
#                     | get pending
#                     | accept
#                     | reject
#                     | update
#                     | no show
#                   >
#     <device_id>:  <unique device ID of the iPhone>
#     <session_id>: [blank for cab requests, required for all others; provided
#                    by the script in response to the initial request]
#     [latitude]:   <latitude of the iPhone>
#     [longitude]:  <longitude of the iPhone>
#     [address]:    [street address for cab request; if present, overrides the
#                    provided latitude and longitude] 
#     [name]:       <user or device provided name of customer>
#
# For the request cab action, latitude, longitude, and name are required fields,
# and the request will fail validation if they're not present.
#
# Responses are by HTTP response in text format, with the body of the response
# being key/value pairs similar in format to the request:
#
#     <status>:     <status code (see below)>
#     <session_id>: <session ID generated by script initially, repeated as 
#                    sanity check through subsequent transactions>
#     [message]:    [descriptive message text]
#
# For a 'dispatch in progress', the script should respond with an ETA for the
# cab and the name of the company/cab number.
#
# Status code is a three digit integer from the following list:
#
#     100  Registration required
#     101  Service Unavailable
#     102  Location not dispatchable
#     103  Asking for dispatch
#     104  Dispatch refused
#     105  Dispatch in progress
#     106  Cab cancelled
#     107  Cab arrived
#     108  Customer no show
#
# TODO:
#
#     Add 'register user' feature
#     Better facility for responding either with key/value pairs or by JSON
#
# Use Case: user gets a cab
#
#     1.  User requests cab
#         a.  device ID and name are placed in %users if not already there.
#         b.  session ID is created as a combination of the device ID and 
#             the timestamp for the current request
#         c.  co-ordinates are translated to address if address is not given.
#         d.  address/co-ordinates are checked for dispatchibility.
#         e.  session ID, address, timestamp, message, and status of 103 are 
#             placed in %sessions.
#         f.  session ID is placed in @pending.
#     2.  Cab company accepts request
#         a.  Cab company sees available requests in @pending
#         b.  Cab company accepts referral, enters ETA.
#         c.  %sessions is updated: status is changed to 105, message is 
#             updated with ETA and name of cab company.
#         d.  session ID is removed from @pending.
#     3.  Cab arrives, user enters cab arrived.
#         a.  %sessions is updated: status is changed to 107
#
# Use Case: status request
#
#     1.  User/cab company requests status update
#         a.  last status and message from %sessions is returned
#
# Use Case: cab cancelled
#      
#     1.  User sends 'cancel cab' from client
#         a.  %sessions is updated: status changed to 106
#         b.  If cab has not been dispatched, session ID is removed from
#             @pending.
#
# ------------------------------------------------------------------------------



use strict ;
use warnings ;
use CGI ;
use Digest::MD5 qw( md5_hex ) ;
use Data::Dumper ;
use DB_File ;



$Data::Dumper::Varname = 'session' ;

my $REGISTRATION_REQUIRED     = 100 ;
my $SERVICE_UNAVAILABLE       = 101 ;
my $LOCATION_NOT_DISPATCHABLE = 102 ;
my $ASKING_FOR_DISPATCH       = 103 ;
my $DISPATCH_REFUSED          = 104 ;
my $DISPATCH_IN_PROGRESS      = 105 ;
my $CAB_CANCELLED             = 106 ;
my $CAB_ARRIVED               = 107 ;
my $CUSTOMER_NO_SHOW          = 108 ;

my %action = (
			    'request cab'    => \&requestCab
			  , 'request status' => \&requestStatus
			  , 'cancel cab'     => \&cancelCab
			  , 'cab arrived'    => \&cabArrived
			  , 'get pending'    => \&getPending
			  , 'get dispatched' => \&getDispatched
			  , 'accept'         => \&accept
			  , 'reject'         => \&reject
			  , 'update'         => \&update
			  , 'no show'        => \&noShow
			  , 'clear database' => \&clearDatabase
			  ) ;

my @abbr = qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec ) ;



tie my %sessions, 'DB_File', '../sessions.dat', O_RDWR | O_CREAT or die "$!" ;
tie my %pending, 'DB_File', '../pending.dat', O_RDWR | O_CREAT or die "$!" ;
tie my %dispatched, 'DB_File', '../dispatched.dat', O_RDWR | O_CREAT or die "$!" ;

my %response = &main( ) ;

print "Content-type: text/html\n\n" ;

if( defined $response{ 'json' } )
{
	delete $response{ 'json' } ;
	print '[ ' ;
	my $size = keys( %response ) ;
	foreach my $key ( sort ( keys %response ) )
	{
		print $response{ $key } ;
		--$size ;
		if( $size )
		{
			print ', ' ;
		}
	}
	print ' ]' ; 
}
else
{
	foreach my $field ( sort ( keys %response ) )
	{
		print $field . ": " . $response{ $field } . "<br />" ;
	}
}

untie %dispatched ;
untie %pending ;
untie %sessions ;



# main
#
# Main request processing subrouting.  Checks that the request is valid and
# dispatches the request depending upon the 'action' field.
# ------------------------------------------------------------------------------

sub main
{
	my $query = new CGI ;
	my %response ;
	my $failureMessage = &requestIsValid( $query ) ;

	if( ! $failureMessage )
	{
		%response = $action{ $query->param( 'action' ) }->( $query ) ;
	}
	else
	{ 
		%response = ( 
					  'status_code' => $SERVICE_UNAVAILABLE, 
					  'message' => $failureMessage  
					  ) ;
	}
	
	return %response ;
}



# requestIsValid
#
# A boolean function that validates the request by checking for the presence of
# all required fields and sane values for same.  Returns true if request passes
# validation, false otherwise.
# ------------------------------------------------------------------------------

sub requestIsValid
{
	my $query = $_[ 0 ] ;

	# 'action' must be defined and have one of the allowable values
	if( defined $query->param( 'action' ) )
	{
		# action must be one of the followinng
		if( ! defined $action{ $query->param( 'action' ) } )
		{
			return "Action specified is not recognized" ;
		}

		if( $query->param( 'action' ) eq 'get pending' ) { return "" ; }
		if( $query->param( 'action' ) eq 'get dispatched' ) { return "" ; }
		if( $query->param( 'action' ) eq 'clear database' ) { return "" ; }
	}
	else
	{
		return "No action specified." ;
	}

	# session id must be present for all requests other than 'request cab',
	# and must exist within %sessions
	if( defined $query->param( 'session_id' ) )
	{
		if(    ! defined $sessions{ $query->param( 'session_id' ) } 
			&& $query->param( 'action' ) ne 'request cab' )
		{
			return "Session ID is not valid" ;
		}
	}
	else
	{
		if( $query->param( 'action' ) ne 'request cab' )
		{
			return "Session ID required." ;
		}
	}

	# device ID must always be present in a request, and exist in either
	# %pending or %dispatched except when requesting a cab.  The submitted 
	# session ID must also match the session ID retrieved from either %pending
	# or %dispatched.
	if( defined $query->param( 'device_id' ) )
	{
		if( $query->param( 'action' ) eq 'request cab' )
		{
			if( ! deviceIdIsValid( $query->param( 'device_id' ) ) )
			{
				return "Invalid device ID." ;
			}
		}
		else
		{
			if(    ! defined $pending{ $query->param( 'device_id' ) }
				   && ! defined $dispatched{ $query->param( 'device_id' ) } )
			{
				return "Device ID is not valid." ;
			}

			if(    $pending{ $query->param( 'device_id' ) } ne $query->param( 'session_id' )
				   && $dispatched{ $query->param( 'device_id' ) } ne $query->param( 'session_id' ) )
			{
				return "Session IDs do not match." ;
			}
		}
	}
	else
	{
		return "Device ID required." ;
	}

	# if the action is 'request cab', then the latitude and longitude must be
	# specified and valid, and if an address is present, it must also be valid
	if( $query->param( 'action' ) eq 'request cab' )
	{
		if( defined $query->param( 'address' ) )
		{
			if( ! addressIsValid( $query->param( 'address' ) ) )
			{
				return "Address is not valid." ;
			}
		}

		if(    defined $query->param( 'latitude' ) 
		    && defined $query->param( 'longitude' ) )
		{
			if( ! latitudeIsValid( $query->param( 'latitude' ) ) )
			{
				return "Latitude is not valid" ;
			}

			if( ! longitudeIsValid( $query->param( 'longitude' ) ) )
			{
				return "Longitude is not valid" ;
			}
		}
		else
		{
			return "Latitude/longitude must be specified." ;
		}
	}

	return "" ;
}



# deviceIdIsValid
#
# Test the device ID to see if it's of the appropriate form
# ------------------------------------------------------------------------------

sub deviceIdIsValid
{
	return 1 ;
}



# addressIsValid
#
# Tests the address to ensure that it's resolvable
# ------------------------------------------------------------------------------

sub addressIsValid
{
	return 1 ;
}



# latitudeIsValid
#
# Test the latitude to see if it's valid
# ------------------------------------------------------------------------------

sub latitudeIsValid
{
	return 1 ;
}



#longitudeIsValid
#
# Test the longitude to see if it's valid
# ------------------------------------------------------------------------------

sub longitudeIsValid
{
	return 1 ;
}



# requestCab
#
# After verifying that an existing request is not already present in %pending or
# %dispatching (in which case it replies with the existing session's data),
# creates a new session ID and session, and puts them into %pending. 
# ------------------------------------------------------------------------------

sub requestCab
{
	my $session_id ;
	my $device_id = $_[ 0 ]->param( 'device_id' ) ;
	my $status = $ASKING_FOR_DISPATCH ;

	# if device ID is already in pending, return existing session
	if( defined $pending{ $device_id } )
	{
		$session_id = $pending{ $device_id } ;
	}
	elsif( defined $dispatched{ $device_id } )
	{
		$session_id = $dispatched{ $device_id } ;
		$status = $DISPATCH_IN_PROGRESS ;
	}
	else
	{
		# get a session ID without a collision
		do
		{
			$session_id = &getSessionId( $_[ 0 ]->param( 'device_id' ) ) ;
		}
		while( defined $sessions{ $session_id } ) ;
		
		# get a street address
		my $address = &getAddress( $_[ 0 ] ) ;

		# timestamp the damn thing
		my @time = localtime( ) ;
		my $timestamp = "$time[ 2 ]:"
			. ( length( $time[ 1 ] ) > 1 ? $time[ 1 ] : '0' . $time[ 1 ] )
			. " " . $abbr[ $time[ 4 ] ] . " " 
			. $time[ 3 ] ;

		# create a session
		$sessions{ $session_id } = Dumper( 
										   { 
											   'status'    => $status
											 , 'device_id' => $_[ 0 ]-> param( 'device_id' )
											 , 'timestamp' => $timestamp 
											 , 'message'   => 'Asking for dispatch.'
											 , 'name'      => $_[ 0 ]->param( 'name' )
											 , 'address'   => $address 
										 } ) ;
		$pending{ $_[ 0 ]->param( 'device_id' ) } = $session_id ;
	}

	my %response = (
					'status_code' => $status,
					'session_id' => $session_id
					) ;

	return %response ;
}



# requestStatus
#
# Returns the status code and last message of the session
# ------------------------------------------------------------------------------

sub requestStatus
{
	my %response ;
	my $session1 ;
	eval( $sessions{ $_[ 0 ]->param( 'session_id' ) } ) ;
	if( defined $session1 )
	{
		%response = (
						'status'     => $session1->{ 'status' },
						'session_id' => $_[ 0 ]->param( 'session_id' ),
						'message'    => $session1->{ 'message' },
					    'address'    => $session1->{ 'address' }
						) ;
	}
	else
	{
		%response = (
						'status'     => 102,
						'message'    => 'Session ID not found.'
						) ;
	}
	return %response ;
}



# getAddress
#
# Takes the query object as parameter.  If an address is present, returns that
# in normalized form; if not, converts latitude and longitude to an address.
# ------------------------------------------------------------------------------

sub getAddress
{
	if( defined $_[ 0 ]->param( 'address' ) )
	{
		return $_[ 0 ]->param( 'address' ) ;
	}
	else
	{
		return "1203-111 W. Georgia St." ;
	}
}



# getSessionId
#
# Returns a generated session ID that uniquely identifies a request and is used
# as a database key for the entire transaction.  Requires device ID as seed for
# MD5 hash.
# ------------------------------------------------------------------------------

sub getSessionId
{
	return md5_hex( $_[ 0 ] . localtime( ) ) ;
}



# cancelCab
#
# Deletes the session from %pending and %dispatched, and updates the session's
# status with $CAB_CANCELLED. 
# ------------------------------------------------------------------------------

sub cancelCab
{
	delete $pending{ $_[ 0 ]->param( 'device_id' ) } ;
	delete $dispatched{ $_[ 0 ]->param( 'device_id' ) } ;

	my $session1 ;
	eval( $sessions{ $_[ 0 ]->param( 'session_id' ) } ) ;
	$session1->{ 'status' } = $CAB_CANCELLED ;
	$session1->{ 'message' } = 'Cab cancelled.' ;

	$sessions{ $_[ 0 ]->param( 'session_id' ) } = Dumper( $session1 ) ;

	my %response = (
					'status'     => $CAB_CANCELLED,
					'message'    => 'Cab cancelled.',
					'session_id' => $_[ 0 ]->param( 'session_id' )
					) ;
	return %response ;
}



# cabArrived
#
# Deletes the session from %dispatched, and updates the session's status with
# $CAB_ARRIVED.
# ------------------------------------------------------------------------------

sub cabArrived
{
	delete $dispatched{ $_[ 0 ]->param( 'device_id' ) } ;

	my $session1 ;
	eval( $sessions{ $_[ 0 ]->param( 'session_id' ) } ) ;
	$session1->{ 'status' } = $CAB_ARRIVED ;
	$session1->{ 'message' } = 'Cab arrived.' ;

	$sessions{ $_[ 0 ]->param( 'session_id' ) } = Dumper( $session1 ) ;

	my %response = (
					'status'     => $CAB_ARRIVED,
					'message'    => 'Cab arrived.',
					'session_id' => $_[ 0 ]->param( 'session_id' )
					) ;
	return %response ;
}



# getPending
#
# Returns the list of pending requests for cabs by building a hash of entries
# where the value is a JSON formatted array describing a single session.
# ------------------------------------------------------------------------------

sub getPending
{
	my %response = ( 'json' => 1 ) ;
	my $session1 ;
	my $ii = 1 ;
	foreach my $key ( keys %pending )
	{
		$key = $pending{ $key } ;
		eval( $sessions{ $key } ) ;
		$response{ $ii } = 
			'[ "' 
			. $key . '", "' 
			. $session1->{ 'address' } . '", "' 
			. $session1->{ 'name' } . '", "'
			. $session1->{ 'device_id' } . '", "'
			. $session1->{ 'timestamp' } . '"'
		    . ' ]' ;
		++$ii ;
	}

	return %response ;
}



# getDispatched
#
# Returns the list of dispatched requests for cabs by building a hash of entries
# where the value is a JSON formatted array describing a single session.
# ------------------------------------------------------------------------------

sub getDispatched
{
	my %response = ( 'json' => 1 ) ;
	my $session1 ;
	my $ii = 1 ;
	foreach my $key ( keys %dispatched )
	{
		$key = $dispatched{ $key } ;
		eval( $sessions{ $key } ) ;
		$response{ $ii } = 
			'[ "' 
			. $key . '", "' 
			. $session1->{ 'address' } . '", "' 
			. $session1->{ 'name' } . '", "'
			. $session1->{ 'device_id' } . '", "'
			. $session1->{ 'timestamp' } . '", "'
			. $session1->{ 'message' } . '"'
		    . ' ]' ;
		++$ii ;
	}

	return %response ;
}



# accept
#
# Accepts a referral; removes the referral from %pending and adds it to 
# %dispatched; updates the status of the session with $DISPATCH_IN_PROGRESS 
# and the message field with the cab company, cab number, and ETA.
# ------------------------------------------------------------------------------

sub accept
{
	delete $pending{ $_[ 0 ]->param( 'device_id' ) } ;
	$dispatched{ $_[ 0 ]->param( 'device_id' ) } = $_[ 0 ]->param( 'session_id' ) ;

	my $session1 ;
	eval( $sessions{ $_[ 0 ]->param( 'session_id' ) } ) ;
	$session1->{ 'status' } = $DISPATCH_IN_PROGRESS ;
	$session1->{ 'message' } = "Yellow cab #358, ETA 25 mins" ;

	$sessions{ $_[ 0 ]->param( 'session_id' ) } = Dumper( $session1 ) ;

	my %response = (
					'status'     => $DISPATCH_IN_PROGRESS,
					'message'    => "Yellow cab #358, ETA 25 mins",
					'session_id' => $_[ 0 ]->param( 'session_id' )
					) ;
	return %response ;
}



# reject
#
# Rejects a referral.  Removes the session from %pending, and updates the 
# status to $DISPATCH_REFUSED.
# ------------------------------------------------------------------------------

sub reject
{
	delete $pending{ $_[ 0 ]->param( 'device_id' ) } ;

	my $session1 ;
	eval( $sessions{ $_[ 0 ]->param( 'session_id' ) } ) ;
	$session1->{ 'status' } = $DISPATCH_REFUSED ;
	$session1->{ 'message' } = 'Dispatch refused.' ;

	$sessions{ $_[ 0 ]->param( 'session_id' ) } = Dumper( $session1 ) ;

	my %response = (
					'status'     => $DISPATCH_REFUSED,
					'message'    => 'Dispatch refused.',
					'session_id' => $_[ 0 ]->param( 'session_id' )
					) ;
	return %response ;
}



# update
#
# Updates the message for the session
# ------------------------------------------------------------------------------

sub update
{
	my $session1 ;
	eval( $sessions{ $_[ 0 ]->param( 'session_id' ) } ) ;
	$session1->{ 'message' } = $_[ 0 ]->param( 'message' ) ;

	$sessions{ $_[ 0 ]->param( 'session_id' ) } = Dumper( $session1 ) ;

	my %response = (
					'message'    => $_[ 0 ]->param( 'message' ),
					'session_id' => $_[ 0 ]->param( 'session_id' )
					) ;
	return %response ;
}



# noShow
#
# Used by the cab company to mark that a customer was not present when the
# cab arrived.  Should be fed back into the customer's history.  Removes the
# referral from %dispatched, and updates the session with $CUSTOMER_NO_SHOW.
# ------------------------------------------------------------------------------

sub noShow
{
	delete $dispatched{ $_[ 0 ]->param( 'device_id' ) } ;

	my $session1 ;
	eval( $sessions{ $_[ 0 ]->param( 'session_id' ) } ) ;
	$session1->{ 'status' } = $CUSTOMER_NO_SHOW ;
	$session1->{ 'message' } = 'Customer not present when cab arrived.' ;

	$sessions{ $_[ 0 ]->param( 'session_id' ) } = Dumper( $session1 ) ;

	my %response = (
					'status'     => $CUSTOMER_NO_SHOW,
					'message'    => 'Customer not present when cab arrived.',
					'session_id' => $_[ 0 ]->param( 'session_id' )
					) ;
	return %response ;
}



# clearDatabase
#
# Utility method for resetting database contents.
# ------------------------------------------------------------------------------

sub clearDatabase
{
	for my $key ( keys %sessions )
	{
		delete $sessions{ $key } ;
	}

	for my $key ( keys %pending )
	{
		delete $pending{ $key } ;
	}

	for my $key ( keys %dispatched )
	{
		delete $dispatched{ $key } ;
	}

	my %response = ( 'message' => 'Database cleared' ) ;
	return %response ;
}

